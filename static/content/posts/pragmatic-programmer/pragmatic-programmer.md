---
slug: 
title: 
date: 
author: 
keywords:
description: 
---

> Why spend your life developing software unless you care about doing it **well**? - The pragmatic programmer

There is a great joy in being good at your craft. The craftmanship mentality is something I'm actively developing in everything I do. If I do something, I aim to do it well.

These are some my key takeaways from reading [the pragmatic programmer]() -

#  Mentality

Proactive vs reactive. Think what you can do.

## Be Proactive 

Be proactive, be in control. I have come across this idea in number of books. Instead of being reactive to the world around me, I must do things **deliberately**. Some of the applications of being proactive as programmer I learnt:
- Criticize and appraise my work regularly. 
- Think solutions, instead of problems. I try to ask myself, what in my control can I do to fix a problem.
- Seek regular feedback.

## Today Not Tomorrow

Being a craftman is often associated with being a perfectionist.

> **Great** software today is often preferable to perfect software tomorrow.
 
I hear this statement regularly. As this is true, I must not use this as an excuse to produce low quality results. The key word here for me is great and today. As a programmer I need to define the minimal acceptable standard that defines my work to be great. These standards should be holistic that consider all the important factors.

## Knowledge portfolio

I have interest in financial markets and investing. There are a lot of concepts from the investing world that could be applied to other aspects of life, including building software. As a programmer that aims to be a craftman I should to treat my knowledge in the same manner I manage assets in my financial portfolio. These are high level strategies that I learnt are applicable to the software world:

- Invest regularly - Investing is a continuous process not a one time thing.
- Diversify - Diversify my knowledge portfolio with different technologies.
- Manage risk - A balance between new risky technologies and more robust existing technologies.
- Review and rebalance - Rebalance my knowledge portfolio on yearly basis.
- Buy low, sell High -  Learn when a tool is still growing and when it has reached its maximum potential I go and learn something else.

## Flexible code

I saw a pattern from almost every project I worked on, unexpected things change. Project's requirements are a living thing. When I am designing a system or implementing a module, I must leave room for changes. Even if today we are 100% sure that the given understand won't change. Because the truth is, it changes. Instead of fighting changes, I should welcome them and have my code support them.

## Be pessimistic

"***Can't read value of undefined*** - Oh! But I thought this should never happen!". Does this sound familiar to you?

Every coder has a set of assumptions that they work based on. I learnt that being pessimistic pays off! 

For example, if I am developing an application that has an external dependency. I would have certain expectations regarding the responses I would receive from these systems. Before processing any responses I always have to validate the data given. Not only that I should validate the data, I also should handle cases when the "unexpected" happen. This way I am more confident that my work is more robust and resilient. 

## Programming by coincidence

Program Deliberately - know what your doing and document your assumptions.

## Ownership and pride

We want to see pride of ownership. "I wrote this, and I stand behind my work."

Tip 70: Sign Your Work

## Tools & Environment

Editor
Code generators
Version control


# Organization

## Dont be a frog
Small problems grow to to become bigger problems. Fix your broken windows immediately and don't be the frog.

## Speak the same language
Unify domain language across teams.

## Measure it to manage it
The key to managing growth of requirements is to point out each new feature's impact on the schedule to the project sponsors.

## Freedom
Degrees of Freedom  - The Specification Trap

## Automation
Automation is an essential component of every project team

## Expectations
The success of a project is measured by how well it meets the expectations of its users. Tip 69: Gently Exceed Your Users' Expectations

## Team up
Team per functionality not per competence. 


# Team

## Estimate
Estimate well. 1- understand , 2- model the system, 3- give per part a value, 4- add range. Estimations should be done regularly.

What to Say When Asked for an Estimate
"I'll get back to you."

Challenges
Start keeping a log of your estimates. For each, track how accurate you turned out to be. If your error was greater than 50%, try to find out where your estimate went wrong.

## Dig for the truth
Tip 51: Don't Gather Requirementsâ€”Dig for Them
Tip 52: Work with a User to Think Like a User

## Tightening the Net
If a bug slips through the net of existing tests, you need to add a new test to trap it next time.
Tip 66: Find Bugs Once


# Principles

Shy orthogonal code.

DRY and make it easier to reuse your code.

better to crash than to trash.

Design for concurrency.

Refactor

Code that is easy to test - Tip 49: Test Your Software, or Your Users Will

Tip 58: Don't Be a Slave to Formal Methods

Tip 63: Coding Ain't Done 'Til All the Tests Run

comment why something is done

